<!doctype html>
<html lang="pl">

<head>
    <meta charset="utf-8">

    <title>Szkolenie JS</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css" type="text/css">
    <link rel="stylesheet" href="css/theme/sky.css" id="theme"  type="text/css">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css" type="text/css">
    <link rel="stylesheet" href="css/additional-styles.css" type="text/css">
    <link rel="stylesheet" href="css/comparision-slider.css" type="text/css">
    <link rel="stylesheet" href="css/custom.css" type="text/css">


    <script src="js/jquery-2.1.1.js"></script>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>

<div class="reveal">
    <div class="slides" id="slides">
        <ul class="breadcrumb">
            <li class="selector"></li>
            <li class="first" data-type="introduced">Wstęp</li>
            <li data-type="type">Typy</li>
            <li data-type="errors">Typy błędów</li>
            <li data-type="templates">Template Literals</li>
            <li data-type="spread">Rest/Spread</li>

            <li data-type="constLet" class="header-keyword"><span class="var">var</span> &nbsp; <span class="let">let</span> &nbsp; <span class="const">const</span></li>
            <li data-type="context" class="header-keyword">this</li>
            <li data-type="functionType">Funkcje</li>

            <li data-type="applyCall"><span class="header-keyword apply">apply</span> &nbsp; <span class="header-keyword call">call</span></li>
            <li data-type="binding" class="header-keyword">bind</li>
            <li data-type="object">Obiekty</li>
            <li data-type="reference">Referencja</li>

            <li data-type="end">Koniec</li>
        </ul>


        <section data-state="introduced">
            <section>
                <h2>Szkolenie JS</h2>
                <p>podstawy</p>

                <aside class="speech">
                    Witam na szkoleniu z JS w zakresie podstawowym, poza samymi podstawami pojawi
                    się parę ciekawostek.
                </aside>
            </section>
            <section>
                <h3>Agenda</h3>

                <aside class="speech">Szybki przegląd tego o czym będziemy dzisiaj mówić, czyli: (patrz główne okno slajdu)</aside>

                <ul>
                    <li class="fragment">typy danych</li>
                    <li class="fragment">typy błędów</li>
                    <li class="fragment type-es6">szablony</li>
                    <li class="fragment type-es6">rest / spred operator</li>
                    <li class="fragment type-es6">jak działa <span class="keyword">var</span>, <span class="keyword">let</span> i <span class="keyword">const</span></li>
                    <li class="fragment">kontekst funkcji</li>
                    <li class="fragment">funkcje</li>
                    <li class="fragment">manipulacje funkcjami</li>
                    <li class="fragment">obiekty</li>
                    <li class="fragment">referencje</li>

                </ul>
            </section>
        </section>

        <section data-state="type">
            <section>
                <aside class="speech">
                    Najbardziej ogólnie można wyróżnić dwa główne typy: proste i złożone. <br>
                    Zacznijmy od typów prostych:
                </aside>
                <h2>proste</h2>
                <ul>
                    <li class="fragment type-with-value">
                        string
                        <aside class="speech"><i>string</i> - czyli zwykły napis, ciąg znaków</aside>
                    </li>
                    <li class="fragment type-with-value">
                        number
                        <aside class="speech"><i>number</i> - czyli liczba, w JS nie ma rozróżnienia na float, int itp.</aside>
                    </li>
                    <li class="fragment type-with-value">
                        boolean
                        <aside class="speech"><i>boolean</i> - czyli wartości true/false</aside>
                    </li>
                    <li class="fragment type-with-value type-es6">
                        Symbol
                        <aside class="speech"><i>Symbol</i> - jest to nowy typ w ES6, parę słów więcej o tym typie za chwilę</aside>
                    </li>

                    <li class="fragment type-without-value">
                        undefined
                        <aside class="speech"><i>undefined</i> - jest typ-wartość w jednym, jest to domyślna wartość każdego nowo zadeklarowanej zmiennej i domyślna wartość zwracana przez funkcje</aside>
                    </li>
                    <li class="fragment type-without-value">
                        null
                        <aside class="speech"><i>null</i> - typ-wartość do którego nie można przypisać wartości, null to null</aside>
                    </li>

                </ul>
            </section>
            <section>
                <h2>Złożone</h2>
                <aside class="speech">Natomiast do typów złożonych zaliczyć można:</aside>
                <ul>
                    <li class="fragment">
                        Object
                        <aside class="speech">
                            I tak naprawdę tylko <i>Object</i>, niektórzy mogą być zdziwieni bo przecież jak to mam jeszcze np. <i>function</i>,
                            tak ale <i>function</i> to nie typ danych tylko funkcja to, że w JS można funkcję przypisać do zmiennej nie
                            implikuje tego, że jest to typ danych.
                        </aside>
                    </li>
                </ul>
            </section>
            <section>
                <aside class="speech">
                    Teraz pojawi się parę wywołań <i>typeof</i> które zwraca typ danego obiektu, zastanów się
                    przez chwilę przy każdym, postaraj się odpowiedzieć na pytanie: "jaki wynik otrzymamy"
                </aside>
                <pre><code class="hljs">
                    > typeof [];
                    <span class="fragment element-log">'object'</span>
                </code></pre>
                <pre class="fragment"><code class="hljs">
                    > typeof null;
                    <span class="fragment element-log">'object'</span>
                </code></pre>
                <pre class="fragment"><code class="hljs">
                    > typeof undefined;
                    <span class="fragment element-log">'undefined'</span>
                </code></pre>
                <pre class="fragment "><code class="hljs">
                    > typeof NaN;
                    <span class="fragment element-log">'number'</span>
                </code></pre>
            </section>
            <section>
                <h3 class="slide-es6"></h3>
                <h3 >Symbols</h3>

                <aside class="speech">
                    <i>Symbol</i> jest nowym typem dodanym w ES6, jest to unikalny ciąg znaków który może zostać wykorzystany np. jako klucz do "prywatnej" zmiennej
                </aside>

                <pre><code class="hljs">
                    <span class="fragment"><!--
                    -->> var mySymbol = Symbol();<!--
                    --><aside class="speech">
                            Aby stworzyć nowy symbol należy wykorzystać do tego celu <b>fabrykę</b> <i>Symbol</i>. <br>
                            Wywołanie tej metody ze słowem kluczowym <b>new</b> spowoduje błąd.
                        </aside><!--
                --></span>
                    <span class="fragment"><!--
                    -->> var yourSymbol = Symbol('some text');<!--
                    --><aside class="speech">
                            Opcjonalnie możemy podać jeden parametr typu "string", jednak ma on zastosowanie jedynie w przypadku debugowania,
                            służy łatwemu rozpoznaniu <i>Symbolu</i> i nie wpływa w żaden sposób na wartość zwracana przez metodę <i>Symbol</i>
                        </aside><!--
                    --></span>
                    <span class="fragment"><!--
                    -->> Symbol('some text') === Symbol('some text');<!--
                    --><aside class="speech">
                            Dlatego też dwa wywołania z tym samym argumentem…
                        </aside><!--
                    --></span>
                    <span class="fragment"><!--
                        -->false<!--
                    --><aside class="speech">
                            …<b>NIE</b> są sobie równe
                            <br>
                            <br>
                            Więcej na temat <i>Symboli</i> znajdziesz w linkach na dole slajdu
                        </aside><!--
                    --></span>
                </code></pre>

                <a href="http://es6-features.org/#SymbolType" class="source"></a>
                <a href="http://es6-features.org/#GlobalSymbols" class="source"></a>
                <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/Symbol11" class="source"></a>
            </section>
        </section>

        <section data-state="errors">
            <h3 class="section-header">Błędy</h3>
            <section>
                <aside class="speech">
                    Możemy wyodrębnić 3 główne rodzaje błędów podczas pisania naszego kodu: (slajd)
                </aside>

                <ul>
                    <li class="fragment">semantyczne (składniowe)</li>
                    <li class="fragment">logiczne</li>
                    <li class="fragment">runtime (w czasie działania aplikacji)</li>
                </ul>
            </section>
            <section>
                <h4>Semantyczne</h4>
                <aside class="speech">
                    <i>Semantyczne</i> czyli te które nas najmniej bolą, zostaną one wyłapane przez interpreter albo już nasze narzędzie
                    parsujące (webpack, typescript) może nam rzucić błąd. Ewentualnie dostaniemy komunikat w konsoli deweloperskiej, że z naszym
                    skryptem jest coś nie tak.
                </aside>
                <pre><code class="hljs">
                    > functon add(number1, number2) {
                        return number1 + number2;
                    }
                    <span class="fragment element-log">Uncaught SyntaxError: Unexpected identifier</span>
                </code></pre>
            </section>
            <section>
                <h4>Logiczne</h4>
                <aside class="speech">
                    <p>Błędy <i>logiczne</i> należą do tych które najtrudniej wyłapać ponieważ kod działa prawidłowo i
                        żadne narzędzie do analizy kodu nie wyłapie błędu w naszym rozumowaniu albo błędnym przełożeniu tego rozumowania na kod.</p>
                    <p>Tak jak w poniższym przykładzie: nazwa metody sugeruje, że wykonuje ona dodawanie natomiast w jej ciele widzimy operacje odejmowania.</p>
                </aside>
                <pre><code class="hljs">
                    > function add(number1, number2) {
                        return number1 - number2;
                    }
                    > add(5, 10);
                    <span class="fragment element-log">-5</span>
                </code></pre>
            </section>
            <section>
                <h4>Runtime</h4>

                <aside class="speech">
                    <p>Błędy w tzw. <i>runtime</i>-ie należą do tych przed którymi możemy zabezpieczyć się na zapas.</p>
                    <p>Ponieważ nie są one wynikiem błędu w naszym kodzie a np. błąd po stronie serwera, zewnętrzną biblioteką lub API.</p>
                </aside>

                <pre><code class="hljs">
                    > function addToServerNumber(number1) {
                        return number1 - getNumberFromServer();
                    }
                    > addToServerNumber(5);
                    <span class="fragment element-log">500 (internal server error)</span>
                </code></pre>
            </section>
        </section>

        <section data-state="templates">
            <h3 class="slide-es6" style="margin: 50px 0 0 0;"></h3>

            <section>
                <aside class="speech">
                    <p>W ES6 istnieje nowy typ <i>napisów</i>…</p>
                </aside>
                <pre><code>
                    <span class="fragment"><!--
                    -->> var oneLine = `I am in one line`;<!--
                    --><aside class="speech">
                            <p>…które mogą być tak jak do tej pory w jednej linii…</p>
                        </aside><!--
                --></span>
                    <span class="fragment"><!--
                    -->> var multiLines = `I
                    am
                    multi
                    lines`;<!--
                    --><aside class="speech">
                            <p>…ale także w wielu liniach bez używania "+".</p>
                        </aside><!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>A co jeżeli w naszym ciągu znaków chcielibyśmy użyć zmiennej?</p>
                    <p>Sprawdźmy to:</p>
                </aside>
                <pre><code>
                    <span class="fragment"><!--
                        -->var name = 'Shaggy';<!--
                    --><aside class="speech"><p>Załóżmy, że mamy zmienną <i>name</i></p></aside><!--
                --></span>
                    <span class="fragment"><!--
                    -->var oldStringWithVariable = 'My name is ' + name;<!--
                    --><aside class="speech"><p>Standardowo połączylibyśmy napis ze zmienną za pomocą + tak jak w przykładzie</p></aside><!--
                --></span>
                    <span class="fragment"><!--
                    -->var newStringWithVariable = `My name is ${name}`;<!--
                    --><aside class="speech">
                            <p>W nowych szablonach mamy jednak możliwość wstawienia zmiennej bezpośrednio w ciąg znaków.</p>
                            <p>Wstawiamy nazwę zmiennej między <b>${</b> i <b>}</b>, dzięki takiemu zapisowi interpreter
                                będzie wiedział, że to co jest pomiędzy tymi znacznikami ma potraktować jak normalny kod JS a nie zwykły napis.</p>
                        </aside><!--
                --></span>
                </code></pre>
            </section>
            <section>
                <a href="https://css-tricks.com/template-literals/">https://css-tricks.com/template-literals/</a>
                <aside class="speech"><p>Nowe szablony potrafią więcej niż tylko wstawianie zmiennych w swoją treść, na slajdzie znajduje się link do bardziej szczegółowego opisu.</p></aside>
            </section>
        </section>

        <section data-state="spread">

            <section>
                <h3>Spread</h3>
                <h4 class="slide-es6"></h4>
                <pre><code class="hljs">
                    <span class="fragment"><!--
                        -->> var values = [4, 5, 6, 7, 8, 9];<!--
                    --><aside class="speech"><p>Załóżmy, że mamy tablicę i chcemy dodać na jej początek brakujące wartości od 1 do 3.</p></aside><!--
                --></span>
                    <span class="fragment"><!--
                    --><aside class="speech"><p>Tworzymy więc dodatkową zmienną w której dodajemy brakujące wartości na początek.</p></aside><!--
                    -->> var digits = [1, 2, 3, <!--
                    --><span class="fragment"><!--
                        --><aside class="speech"><p>Używając <i>spread operator</i>(<b>...</b>) rozdzielamy poszczególne elementy tablicy na pojedyńcze elementy</p></aside><!--
                        -->...values<!--
                    --></span>];<!--
                --></span>
                    <span class="fragment">> digits;</span>
                    <span class="fragment">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
                </code></pre>
            </section>
            <section>
                <h3>Rest</h3>
                <h4 class="slide-es6"></h4>

                <pre><code class="hljs" style="display: flex; flex-direction: column">
                    <span style="order: 2;" class="fragment"><!--
                    --><aside class="speech"><p>Załóżmy, że chcemy stworzyć funkcje która będzie przyjmowała dowolną ilość argumentów.</p></aside><!--
-->                > joinChars('M', 'y', ' ', 'n', 'a', 'm', 'e');<!--
                    --></span>
                    <span style="order: 1;" class="fragment"><!--
                        --><aside class="speech"><p>Stwórzmy więc taką metodę, problematyczne jednak jest ile argumentów nadać?</p></aside>
                > function joinChars(<span class="fragment"><!--
                        --><aside class="speech">
                            <p>Użyjemy więc do tego celu <i>rest operator</i></p>
                            <p>Pewnie zauważyłeś, że <i>rest</i> i <i>spread</i> operator wyglądają tak samo (<b>...</b>).
                                JS w zależności od miejsca wykorzystania sam wie jak go interpretować</p>
                            <p><i>Rest</i> różni się od <i>spread</i> tym, że zbiera wszystkie argumenty od miejsca
                                deklaracji do końca listy argumentów, wkłada je do tablicy i przypisuje do zmiennej o podanej
                                nazwie (w naszym przykładzie zmienna to: <i>chars</i>).</p>
                        </aside><!--
                        -->...chars<!--
                    --></span>) {
                    return chars.join('')
                }<!--
                    --></span><!--
                    --><span class="element-log fragment" style="order: 3"><!--
-->                My name
                </span>
                </code></pre>
            </section>
        </section>

        <section data-state="constLet">
            <section data-state="varLetConst">
                <aside class="speech">
                    <p>Zapewne wiesz jak deklarować zmienną przy użyciu <u>var</u> ale czy znasz różnice między <u>var</u> a nowymi <u>let</u> i <u>const</u>?</p>
                    <p>W tej sekcji przyjżymy się tym mechanikom i wyjaśnimy sobie różnice między nimi</p>
                </aside>
            </section>
            <section data-state="var">
                <aside class="speech">
                    <p>Zacznijmy od tego czy wiesz co się stanie jeżeli spróbujemy użyć zmiennej której nigdzie nie zadeklarowaliśmy?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        console.log(message);
                    }
                    > log()
                    <span class="fragment element-log"><!--
                        --><aside class="speech"><p>Dostaniemy komunikat błędu mówiący o tym, że zmienna o takiej nazwie nie została zdefiniowana.</p></aside><!--
                    -->'message is not defined'
                    </span>
                </code></pre>
            </section>
            <section>
                <aside class="speech"><p>Czy wiesz jakie będą skutki wyświetlenia zmiennej przed jej deklaracją za pomocą <u>var</u>, po niej i po przypisaniu wartości?</p></aside>
                <pre><code class="hljs">
                    > function log() {
                        console.log('1:', message);
                        var message;
                        console.log('2:', message);
                        message = 'Hi :)';
                        console.log('3:', message);
                    }
                    > log();
                    <span class="element-log">'1:' <span class="fragment">'undefined'</span></span>
                    <span class="element-log">'2:' <span class="fragment">'undefined'</span></span>
                    <span class="element-log">'3:' <span class="fragment">'Hi :)'</span></span>
                </code></pre>
            </section>

            <section>
                <aside class="speech">
                    <p>A czy wiesz co się stanie jeżeli spróbujemy przypisać wartość do zmiennej przed jej deklaracją skoro domyślna wartość zmiennej podczas deklaracji to <i>undefined</i>?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        message = 'I am the chosen one'
                        console.log(message);
                        var message;
                    }
                    > log();
                    <span class="fragment element-log">'I am the chosen one'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Ok, a jeżeli wstawimy deklaracje zmiennej w instrukcję <u>if</u> która będzie spełniona a użyjemy jej poza tą instrukcją?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        if(true) {
                            var message = 'I need a hamster';
                        }
                        console.log(message);
                    }
                    > log();
                    <span class="fragment element-log">'I need a hamster'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>A co się zmienni jeżeli warunek nie będzie spełniony?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        if(false) {
                            var message = 'I need a hamster';
                        }
                        console.log(message);
                    }
                    > log();
                    <span class="fragment element-log">undefined</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Jeżeli niektóre z tych rezultatów wprawiło Cie w zakłopotanie to wiec, że za wszystko odpowiedzialny jest <b>HOISTING</b></p>
                </aside>
                <h1>HOISTING</h1>
            </section>
            <section>
                <aside class="speech">
                    <p>Jeżeli po dowiedzeniu się, że <i>hoisting</i> jest odpowiedzialny za całe zamieszanie masz podobną minę spieszę z wyjaśnieniami.</p>
                </aside>
                <img src="assets/hoisting.jpeg" alt="hoisting" style="width: 100%;">
            </section>
            <section data-state="var">
                <aside class="speech">
                    <p><b>Hoisting</b> to nic innego jak przeniesienie deklaracji zmiennej na początek funkcji.</p>
                    <p>To dlatego, że <u>var</u> ma funkcyjny zakres widoczności, czyli nie ważne w którym miejscu
                        funkcji zadeklarujemy zmienna bo i tak będzie ona przeniesiona na początek.</p>
                </aside>
                <img src="assets/hoisting-wyjasnienie.png" alt="hoisting" style="width: 70%;">
            </section>
            <section>
                <pre><code class="hljs">
                    <aside class="speech">
                        <p>Jedne z powyższych przykładów zostanie więc zinterpretowany w taki sposób jak na slajdzie.</p>
                    </aside>
                    > function log() {
                        var message;

                        if(false) {
                            message = 'I need a hamster';
                        }
                        console.log(message);
                    }
                    > log();
                    <span class="element-log">undefined</span>
                </code></pre>
            </section>

            <section data-state="let">
                <aside class="speech">
                    <p>Przejdźmy teraz do <u>let</u>. Deklaracja zmiennej za pomocą <u>let</u> różni się tylko zmianą słowa kluczowego</p>
                    <p>Więc pewnie nie będzie dla Ciebie zaskoczeniem wynik wywołania.</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        let message = 'Hi';
                        console.log(message);
                    }
                    > log();
                    <span class="fragment element-log">'Hi'</span>
                </code></pre>
            </section>
            <section data-state="let">
                <aside class="speech">
                    <p>Jeżeli spróbujemy nadpisać raz zadeklarowaną wartość też wszystko przejdzie gładko.</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        let message = 'Hi';
                        message = 'folks';
                        console.log(message);
                    }
                    > log();
                    <span class="fragment element-log">'folks'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>A co jeżeli zadeklarujemy zmienna wewnątrz warunku który nie zostanie spełniony?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        if(false) {
                            let message = 'Flag is set';
                        }

                        console.log(message)
                    }
                    > log();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Błąd ten wystąpił ponieważ <u>let</u> i <u>const</u> mają zakres widoczności <b>blokowy</b> a nie <i>funkcyjny</i>.</p>
                            <p>Oznacza to, że zmienna jest widoczna w bloku <b>od miejsca deklaracji</b> do <b>}</b></p>
                        </aside><!--
                        -->'"message" is not defined'<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Skoro mamy już pojęcie o tym jak działa <u>let</u>, czy jesteś w stanie powiedzieć jaki będzie rezultat tego kodu?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        if(true) {
                            let message = 'Flag is set';
                        }

                        console.log(message)
                    }
                    > log();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Jeżeli zaskoczył Cie fakt, że pojawił się błąd zamiast wartości
                                przypominam: <u>let</u> ma <b>blokowy</b> zakres widoczności</p>
                        </aside><!--
                        -->'"message" is not defined'<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Więc aby nasz kod działał poprawnie musimy przenieść <i>console.log</i> do warunku.</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        if(true) {
                            let message = 'Flag is set';
                            console.log(message);
                        }

                    }
                    > log();
                    <span class="fragment element-log">'Flag is set'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Ok, a co w przypadku kiedy deklarujemy 2 razy zmienną o tej samej nazwie ale w innych blokach?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        let message = 'I will kil You';

                        if(true) {
                            let message = 'Flag is set';
                        }

                        console.log(message);
                    }
                    > log();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>A no nie za wiele, tak jak mówiliśmy wcześniej <u>let</u> jest widoczny per blok kodu.</p>
                            <p>Co za tym idzie jeżeli zadeklarujemy w innym bloku zmienną która powinna być tam widoczna ponieważ
                            jest zadeklarowana w bloku nadrzędnym to deklaracja w bloku poniżej nadpisze deklaracje powyżej.
                            <b>UWAGA</b> nie jest to zmiana wartości zmiennej zadeklarowanej wcześniej. Co widać po wyniku
                            wywołania metody <i>log</i></p>
                        </aside><!--
                        -->'I will kill You'<!--
                    --></span>
                </code></pre>
            </section>
            <section data-state="let">
                <aside class="speech">
                    <p>To jeżeli możemy nadpisywać deklaracje w różnych blokach zmiennej o tej samej nazwie nawet w przypadku
                        gdy ich zakresy widoczności się zazębiają to co się stanie jeżeli spróbujemy zadeklarować 2 razy
                    zmienną o takiej samej nazwie w tym samym bloku?</p>
                </aside>
                <pre><code class="hljs">
                    > function log() {
                        let message = 'I will kill You';
                        let message = 'Lemon tree';

                        console.log(message);
                    }
                    > log();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Możemy zmieniać wartość przypisaną do zmiennej zadeklarowanej jako <u>let</u> ale w obrębie
                            jednego bloku każda zmienna może być zadeklarowana tylko raz.</p>
                        </aside><!--
                        -->'Identifier "message" has already been declared'<!--
                    --></span>
                </code></pre>
            </section>


            <section data-state="const">
                <aside class="speech">
                    <p>Jak nie trudno się domyśleć aby zadeklarować stałą należy użyć <u>const</u>.</p>
                </aside>
                <pre><code class="hljs">
                    > const message = 'You will not change me.';
                    > <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Jak wcześniej wspomniałem zmienne zadeklarowane jako <u>const</u> są traktowane
                                jako stałe więc powtórne przypisanie do nich wartości…</p>
                        </aside><!--
                        -->message = 'I will hahaha';<!--
                    --></span>
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>…spowoduje pojawienie się błędu.</p>
                        </aside><!--
                        -->'Assignment  to constant variable'<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>To super, możemy teraz tworzyć tablice bez obawy, że ich zawartość zostanie zmieniona czy nadpisana</p>
                </aside>
                <pre><code class="hljs">
                    > const immutableArray = [1, 2, 3, 400];
                    > function change(arrayToChange) {
                        arrayToChange.pop();
                    }
                    > change(immutableArray);
                    > immutableArray;
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>No właśnie nie. Można powiedzieć, że <u>cosnt</u> dba o to abyśmy nie nadpisali na nowo już zadeklarowanej zmiennej.</p>
                            <p>Jednak w przypadku obiektów (tablice też są obiektami) nie jest pilnowana ich zawartość.</p>
                            <p>Możemy więc zmieniać zawartość obiektu który jest zadeklarowany jako <u>const</u> jednak nie możemy do tej zmiennej
                            przypisać zupełnie nowej wartości</p>
                        </aside><!--
                        -->[1, 2, 3]<!--
                    --></span>
                </code></pre>
            </section>
        </section>

        <section data-state="context">
            <section>
                <aside class="speech">
                    <p>Jest to najbardziej kluczowa część tego szkolenia.</p>
                    <p>Jeżeli uznasz, że pewne rzeczy są niejasne bądź niezrozumiałe poproś kogoś bardziej doświadczonego
                        o wyjaśnienie Twoich wątpliwości.</p>
                </aside>
            </section>
            <section>
                <aside class="speech">
                    <p>W porównaniu do innych języków programowania w JS konteks funkcji (<u>this</u>) jest zależny od miejsca
                        wywołania a nie deklaracji.</p>
                    <p>Jeżeli funkcja nie jest przypisana do obiektu i nie jest używana jako konstruktor (więcej na temat
                        konstruktorów w części z obiektami) kontekstem jej wywołania jest <u>window</u>.</p>
                    <p>W przykładzie staramy sie pobrać właściwość <i>sum</i> z obiektu <u>window</u>, zwiększyć ją
                        podaną o daną wartość i zwrócić jako wynik.</p>
                </aside>
                <pre><code class="hljs">
                > function increaseSumBy(value) {
                    this.sum += value;
                    return this.sum;
                }
                > increaseSumBy(5);
                <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>Ponieważ w obiekcie <u>window</u> nie znajduje się właściwość <i>sum</i> zwracany jest
                            <i>undefined</i> a dowolna liczba + <i>undefined</i> nie jest poprawną liczbą więc jako wynik
                        otrzymujemy <i>NaN</i></p>
                    </aside><!--
                    -->NaN<!--
                --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Aby to poprawić przypiszmy naszą funkcję do stworzonego obiektu.</p>
                    <p>Aby przypisać funkcję do obiektu/zmiennej należy podać jej nazwę bez nawiasów.</p>
                    <p>Jak wcześniej było mówione kontekstem funkcji (<u>this</u>) nie jest miejsce deklaracji
                    tylko miejsce wywołania. Więc w momencie kiedy przypiszemy funkcję <i>increaseSumBy</i> do
                    właściwości <i>increase</i> zmienia się też kontekst metody z <u>window</u> na <i>obj</i>.</p>
                </aside>
                <pre><code class="hljs">
                > function increaseSumBy(value) {
                    this.sum += value;
                    return this.sum;
                }
                > var obj = { sum: 5, increase: increaseSumBy }
                > obj.increase(5);
                <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>Jak widać po wywołaniu metody <i>increase</i> wartość która była przypisana do właściwości
                        <i>sum</i> została zwiększona prawidło mimo, że nic nie zostało zmienione w <i>increaseSumBy</i>.</p>
                    </aside><!--
                    -->10<!--
                --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Możemy też wykorzystywać kontekst w przypadku kiedy przypinamy callback dla jakiegoś zdarzenia.</p>
                    <p>W takich sytuacjach należy pamiętać, że każda funkcja przypisana do eventu jest wywoływana w
                    kontekście węzła do którego został przypisany.</p>
                </aside>
                <pre><code class="hljs">
                > document.getElementById('save')
                          .addEventListener('click', function() {
                              console.log(this);
                          });
                <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>Dlatego właśnie <i>console.log</i> wypisał przycisk do którego została przypięta funkcja.</p>
                        <p>UWAGA!!! nie jest to <u>string</u> tylko htmlowy <i>node</i> (węzeł) więc posiada on również
                        własne metody i właściwości których możemy używać wedle potrzeb lub je modyfikować.</p>
                    </aside><!--
                    -->&lt;button&gt;Save&lt;/button&gt;<!--
                --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Ten sam efekt dostaniemy kiedy przypiszemy zdarzenie bezpośrednio w pliku html.</p>
                </aside>
                <pre><code class="hljs">
        > &lt;button onclick="console.log(this);"&gt;Save&lt;/button&gt;
        <span class="fragment element-log">&lt;button onclick="console.log(this);"&gt;Save&lt;/button&gt;</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Wiedząc już, że dla funkcji nie jest ważne to gdzie jest zadeklarowana ale to gdzie
                    jest wywołana spróbuj przewidzieć jaki wynik będzie dla podanych niżej porównań.</p>
                </aside>
                <pre><code class="hljs">
                    > var obj1 = {
                        value: 10,
                        getValue: function() {
                            return this.value;
                        }
                    };
                    > obj1.value === obj1.getValue();
                    <span class="fragment element-log">true</span>
                    > var obj2 = {
                        value: 20,
                        getValue: obj1.getValue
                    };
                    > obj2.value === obj2.getValue();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Jeżeli jesteś zdziwiony/zdziwiona tym, to porównanie okazało się prawdziwe wyjaśnijmy co tu
                            się stało</p>
                            <p>Stworzyliśmy 2 obiekty <i>obj1</i> i <i>obj2</i>, oba posiadają właściwości <i>value</i>
                                i <i>getValue</i></p>
                            <p>W <i>obj1</i> do <i>getValue</i> przypisaliśmy funkcję która korzysta z <u>this</u> w celu pobrania
                            <i>value</i></p>
                            <p>Podczas wywołania <i>obj1.getValue()</i> jasne jest, że jest ona wywołana w kontekście
                                właśnie <i>obj1</i> ponieważ została zadeklarowana w jego obrębie.</p>
                            <p>Natomiast w <i>obj2</i> przypisujemy do <i>getValue</i> metodę z <i>obj1</i>.</p>
                            <p>Jak wcześniej mówiliśmy funkcje w JS zmieniają kontekst w zależności od miejsca wywołania.
                            Więc jeżeli metodę z <i>obj1</i> przypisaliśmy do <i>obj2</i> i wywołaliśmy ją za pośrednictwem
                                właśnie <i>obj2</i> zmieniliśmy kontekst jej wywołania z <i>obj1</i> na <i>obj2</i></p>
                        </aside><!--
                        -->true<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <h3>strict mode</h3>
                <aside class="speech">
                    <p>Jest pewna różnica w działanie kontekstu w <i>strict mode</i>.</p>
                </aside>
                <pre class="fragment"><code class="hljs">
                    > function logContext1() {
                        console.log(this)
                    }
                    > logContext1();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Tak jak wcześniej mówiliśmy, jeżeli metoda nie jest nigdzie przypisana to jej domyślnym
                                kontekstem wywołania jest <u>window</u>.</p>
                        </aside><!--
                        -->window<!--
                    --></span>
                </code></pre>
                <pre class="fragment"><code class="hljs">
                    > 'use strict';
                    > function logContext2() {
                        console.log(this)
                    }
                    > logContext2();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>W <i>strict mode</i> natomiast jeżeli metoda nie jest przypisana do żadnego kontekstu
                            powinien on być <u>undefined</u>. Powinien ponieważ…</p>
                        </aside><!--
                        -->undefined<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <h3>strict mode</h3>
                <aside class="speech">
                    <p>…jak można wyczytać w dokumentacji niektóre przeglądarki nie zaimplementowały tej funkcjonalności i nawet
                    używając <i>strict mode</i> kontekst 'samotnych' funkcji jest równy <u>window</u>.</p>
                    <p>Natomiast w takich środowiskach jak <i>NodeJS</i> jest to zaimplementowane prawidłowo.</p>
                </aside>
                <div class="warning-message">
                    In the second example, this should be <span class="keyword">undefined</span>, because <span class="keyword">logContext2</span> was called directly and
                    not as a method or property of an object (e.g. <span class="keyword">window.logContext2()</span>). This feature <span class="bold">wasn't</span> implemented
                    in some browsers when they first started to support strict mode. As a result, they incorrectly
                    returned the window object.
                </div>
                <a  class="source" href="https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Operatory/this#Simple_call"></a>
            </section>
            <section>
                <aside class="speech">
                    <p>Aby odpalić ćwiczenia przejdź w konsoli do katalogu <i>exercises</i> i wykonaj polecenie <i>node this.js</i></p>
                </aside>
                <img src="assets/lets-code.png" alt="let's code" class="lets-code">
            </section>
        </section>

        <section data-state="functionType">
            <section>
                <aside class="speech">
                    <p>Nie raz pewnie deklarowałeś/deklarowałaś funkcję, więc zapewne rezultat następnego kroku
                        będzie dla ciebie oczywisty</p>
                </aside>
                <pre><code class="hljs">
                    > function add(a, b) {
                        return a + b;
                    }
                    <span class="fragment">> add(2, 2);</span>
                    <span class="fragment element-log">4</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>A czy wiesz jaki wynik zwróci ta funkcja?</p>
                </aside>
                <pre><code class="hljs">
                    > function add(a, b) {
                        a + b;
                    }
                    <span class="fragment">> add(2, 2);</span>
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Jeżeli metoda nie ma jawnie zadeklarowanej sekcji <u>return</u> zwraca ona <i>undefined</i>.</p>
                            <p>Czyli każda metoda która nie zwraca <i>nic</i>, tak naprawdę będzie zwracać <i>undefined</i>.</p>
                        </aside><!--
                        -->undefined<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Rozważmy teraz pare wariacji metody którą widzieliśmy przed chwilą:</p>
                </aside>
                <pre><code class="hljs">
                    /**
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Taką wersje zaimplementowaliśmy na samym początku.</p>
                        </aside><!--
                        -->* add(1, 2) > 3<!--
                    --></span>
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Jeżeli byśmy chcieli dodać jeszcze jedna opcjonalną liczbę to też nie było by zapewne
                            dramatu, jakiś <u>if</u> i sprawa by się rozwiązała</p>
                        </aside><!--
                        -->* add(1, 2, 3) > 6<!--
                    --></span>
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Jeżeli zapragniemy dodać jeszcze 'kilka' opcjonalnych parametrów to zrobi się z tego całkiem pokaźna
                            <u>if</u>ologia</p>
                        </aside><!--
                        -->* add(1, 1, 1, 10, -4, 2, 5) > 16<!--
                    --></span>
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>A jak przewidzieć ilość <u>if</u>ów jeżeli będziemy chcieli mieć funkcje dla dowolnej liczy argumentów</p>
                        </aside><!--
                        -->* add(n1, n2, n3, ... )<!--
                    --></span>
                    */<!--
                    --><span class="fragment"><!--
                    --><aside class="speech">
                        <p>Ile argumentów przewidzieć? jak to zaimplementować żeby nie pogubić się w <u>if</u>ach?</p>
                    </aside>
                    function add(/* ??? */) {
                        return // ???
                    }</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Na sam początek musimy do czegoś dodawać nasze kolejne liczby więc zadeklarujmy <i>sum</i>.</p>
                    <p>Patrząc na drugą zmienną można odnieść wrażenie, że będziemy po czymś iterować. Jest to prawda, mogłeś
                    też pomyśleć, że wykorzystamy do tego <i>rest operator</i>. Nie było by to złe rozwiązanie ale powiedzmy,
                    że nie możesz używać funkcjonalności z ES6 bo działasz na kodzie który pamięta jeszcze dinozaury</p>
                </aside>
                <pre><code class="hljs">
                    > function add() {
                        var sum = 0;
                        var argIndex;
                        <span class="fragment" style="position: absolute; top: 120px; left: 494px;"><!--
                            --><aside class="speech">
                                <p>Istnieje coś takiego jak <u>arguments</u>, jest to obiekt dostępny w funkcjach i przechowuje
                                wszystkie argumenty przekazane do funkcji.</p>
                            </aside><!--
                            -->arguments<!--
                        --></span>
                        <span class="fragment"><!--
                            --><aside class="speech">
                                <p>Jeżeli wiemy już jak przechwycić wszystkie argumenty wystarczy teraz, że prziterujemy
                                po wszystkich elementach <u>arguments</u> i dodamy poszczególne wartości do <i>sum</i></p>
                            </aside><!--
                        -->for (argIndex in <span style="visibility: hidden;">arguments</span>) {
                            sum += arguments[argIndex];
                        }<!--
                        --></span>
                        <span class="fragment"><!--
                            --><aside class="speech">
                                <p>Na koniec zwracamy wynik sumowania</p>
                            </aside><!--
                            -->return sum;<!--
                        --></span>
                    }
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Takie wywołanie metody powinno dać prawidłowy wynik czyli…</p>
                        </aside><!--
                        -->> add(1, 1, 1, 10, -4, 2, 5);<!--
                    --></span>
                    <span class="fragment element-log">16</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Należy jednak pamiętać, że <u>arguments</u> <b>NIE JEST</b> tablicą, jest obiektem tablico-podobnym
                    który z tablicą łączy tylko właściwość <i>length</i>.</p>
                    <p>Więcej do poczytania na: <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Funkcje/arguments" target="_blank">MDN web docs</a></p>
                </aside>
                <div style="width: 350px; display: inline-block;">
                    <img src="assets/warning.jpg" alt="warning" style="width: 100%;">
                </div>
                <div>
                    arguments &ne; array
                </div>
            </section>
            <section>
                <aside class="speech">
                    <p>Znacznie częściej niż samotne funkcje tworzymy je w obrębie obiektów, przyjrzyjmy się więc sposobom
                    w jakie możemy to zrobić.</p>
                </aside>
                <pre><code class="hljs">
                    > var myObj = {
                        <span class="fragment"><!--
                            --><aside class="speech">
                                <p>W klasyczny, najlepiej nam znany sposób czyli przypisujemy anonimową funkcję
                                do właściwości obiektu.</p>
                            </aside><!--
                            -->fun1: function() {},<!--
                        --></span>
                        <span class="fragment type-es6"><!--
                            --><aside class="speech">
                                <p>ES6 umożliwia nam też zadeklarowanie tzw. <i>arrow function</i> o której trochę więcej za chwilę.</p>
                            </aside><!--
                            -->fun2: () => {},<!--
                        --></span>
                        <span class="fragment type-es6"><!--
                            --><aside class="speech">
                                <p>Skrócona wersja normalnej deklaracji która na 99% zachowuje się tak samo (o tym 1% za chwilę).</p>
                            </aside><!--
                            -->fun3() {}<!--
                        --></span>
                    };
                </code></pre>
            </section>
            <section>
                <h3 class="slide-es6"></h3>
                <aside class="speech">
                    <p><i>Arrow function</i> różni się tym od zwykłej metody, że nie ma własnego kontekstu wywołania,
                    dziedziczy go jednak od rodzica.</p>
                    <p>Istnieje możliwość deklaracji w jendnej linii
                    <pre><code>
        var af = () => 123;
                    </code></pre>
                    która działa tak samo jak:
                    <pre><code>
        var nf = function() {
            return 123;
        }
                    </code></pre>
                    </p>
                    <p>Jeżeli chcemy zapisać więcej niż jedna linijkę możemy to zrobić dodając <b>{</b> <b>}</b>
                    za <b>=></b>
                    <pre><code>
        var af = () => {
            return 123;
        }
                    </code></pre>
                    </p>
                    <p>Istnieje też możliwość zwrócenia obiektu za pomocą jednolinijkowej <i>arrow function</i>, wystarczy zapisać go
                    jako wyrażenie (czyli pomiędzy <b>(</b> i <b>)</b> )
                    <pre><code>
        var af = () => ({ type: 'arrow function' });
                </code></pre>
                    </p>
                    <p>Należy też pamiętać, że wywołując <u>arguments</u> w <i>arrow function</i> nie dostaniemy listy argumentów
                    z funkcji strzałkowej tylko (o ile taka istnieje) z funkcji w której <i>arrow function</i> została wywołana.</p>
                    <p>Czy mając powyższą ściągawkę jesteś wstanie powiedzieć jaki będzie wynik operacji na slajdzie?</p>
                </aside>
                <pre><code class="hljs">
                    > var myObj = {
                        fun1: () => this,
                        fun2() {
                            return  {
                                fun21: () => this
                            }
                        }
                    };
                    > myObj === myObj.fun1();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p><i>Arrow function</i> nie ma swojego kontekstu więc jeżeli zadeklarujemy taką metode w globalnie
                                dostępnym obiekcie.</p>
                            <p>W momencie odwołana się do <u>this</u> pobierany jest <i>window</i>.</p>
                        </aside><!--
                        -->false<!--
                    --></span>
                    > myObj === myObj.fun2().fun21();
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p><i>fun2</i> jest normalną funkcją więc jej kontekstem jest <i>myObj</i> a jej rezultatem
                            jest obiekt zawierający metodę <i>fun21</i>.</p>
                            <p>Jeżeli <i>fun21</i> była by normalną funkcją to jej kontekstem był by obiekt:
                            <pre><code>
            {
                fun21: f() { /*...*/ }
            }
                            </code></pre></p>
                            <p>Ponieważ jednak <i>fun21</i> jest <i>arrow function</i> jej kontekstem wywołainem jest kontest
                            w którym została wywołana metoda <i>fun2</i>.</p>
                        </aside><!--
                        -->true<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <h3 class="slide-es6"></h3>
                <aside class="speech">
                    <p>Pamiętacie jak mówiłem, że te dwa sposoby deklaracji są prawie taki sam.</p>
                    <p>Jedyna różnica między nimi jest taka, że pierwszą możemy wykorzystać jako konstruktor natomiast drugą
                    już nie bardzo.</p>
                    <p>Po wykonaniu:
                    <pre><code>
            var instance = new myObj.fun1();
                    </code></pre>
                    dostaniemy nową instancję <i>myObj.fun1</i>
                    </p>

                    <p>Natomiast jeżeli spróbujemy tego samego z <i>fun2</i>:
                    <pre><code>
            var instance = new myObj.fun2();
                    </code></pre>
                    dostaniemy komunika błędu <i>myObj.fun2 is not a constructor</i>
                    </p>

                </aside>
                <pre><code class="hljs">
                    > var myObj = {
                        fun1: function() { /* ... */ },
                        fun2() { /* ... */ }
                    };
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Aby odpalić ćwiczenia przejdź w konsoli do katalogu <i>exercises</i> i wykonaj polecenie <i>node arrow.js</i></p>
                </aside>
                <img src="assets/lets-code.png" alt="let's code" class="lets-code">
            </section>
        </section>

        <section data-state="applyCall">
            <section data-state="applyCall">
                <aside class="speech">
                    <p>W działaniu metod <i>apply</i> i <i>call</i> różnią się tylko typem przyjmowania drugiego argumentu.</p>
                </aside>
                <pre class="fragment"><code class="hljs"><!--
                    --><aside class="speech">
                        <p>Zadeklarujmy sobie funkcję na której będziemy wywoływać nasze metody.</p>
                    </aside>
                    > var sum = function(num1, num2, num3) {
                        this.accumulator = num1 + num2 + num3;
                    }
                </code></pre>
            </section>
            <section data-state="apply">
                <aside class="speech">
                    <p><i>apply</i> przyjmuje dwa argumenty i na ich podstawie wywołuje metodę na której zostało wywołane.</p>
                </aside>
                <pre><code class="hljs"><!--
                    --><span class="fragment" data-fragment-index="3"><!--
                        --><aside class="speech">
                            <p>Zadeklarujmy więc nasz obiekt.</p>
                        </aside>
                    > var accumulatorObj = {};<!--
                    --></span>
                    <span>> sum.apply(<span class="fragment" data-fragment-index="2"><!--
                        --><aside class="speech">
                            <p>Pierwszym argumentem jest kontekst wywołania funkcji który nadpisuje domyślne zachowanie.</p>
                        </aside><!--
                        -->accumulatorObj<!--
                    --></span>, <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Jako drugi argument przyjmuje tablicę która zawiera poszczególne argumenty potrzebne do wywołania
                            metody</p>
                        </aside><!--
                        -->[1, 2,3]<!--
                    --></span>);</span>
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Więc po wypisaniu obiektu który przekazaliśmy jako kontekst wywołania funkcji dostaniemy
                            odpowiednio zmodyfikowany obiekt.</p>
                        </aside><!--
                        -->> accumulatorObj</span>
                    <span class="fragment element-log">{ accumulator: 6 }</span>
                </code></pre>
            </section>
            <section data-state="call">
                <aside class="speech">
                    <p><i>Call</i> robi dokładnie to samo co <i>apply</i> różnią się one jedynie sposobem wywołania.</p>
                </aside>
                <pre><code class="hljs"><!--
                    --><span class="fragment" data-fragment-index="3"><!--
                        --><aside class="speech">
                            <p>Ponownie zadeklarujmy obiekt który jest przekazany jako
                            kontekst wywołania.</p>
                        </aside>
                    > var accumulatorObj = {};<!--
                    --></span>
                    > sum.call(<span class="fragment" data-fragment-index="2"><!--
                    --><aside class="speech">
                        <p>Czyli jako pierwszy argument przekazujemy kontekst wywołania funkcji.</p>
                    </aside><!--
                    -->accumulatorObj<!--
                    --></span>, <span class="fragment"><!--
                    --><aside class="speech">
                        <p>Jako kolejne argument oddzielone <b>,</b> (przecinkiem) podajemy argumenty które mają trafić do funkcji</p>
                    </aside><!--
                    -->1, 2, 3<!--
                    --></span>);
                    <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Więc po wypisaniu obiektu który przekazaliśmy jako kontekst wywołania funkcji dostaniemy
                            odpowiednio zmodyfikowany obiekt.</p>
                        </aside><!--
                        -->> accumulatorObj</span>
                    <span class="fragment element-log">{ accumulator: 6 }</span>
                </code></pre>
            </section>
            <section data-state="applyCall">
                <aside class="speech">
                    <p>Tak wygląda definicja obu metod w dokumentacji.</p>
                </aside>
                <pre><code class="hljs">
                    fun.apply(thisArg, [argsArray])
                </code></pre>

                <pre><code class="hljs">
                    fun.call(thisArg, arg1, arg2, ...)
                </code></pre>
            </section>
        </section>

        <section data-state="binding">
            <section>
                <aside class="speech">
                    <p><i>bind</i> jest bardzo pomocną metodą. Można powiedzieć, że kopiuje funkcje która ją wywołała z
                        pewnymi zmianami…</p>
                </aside>
            </section>

            <section>
                <aside class="speech">
                    <p>Załóżmy, że mamy obiekt który przechowuje nam jakieś funkcje i chcemy wykorzystać je jako event litenery.
                        Możemy przekazać je w taki sposób (patrz slajd)</p>
                    <p>Jest jednak pewien problem, jeżeli korzystamy w takiej metodzie z <u>this</u>, zostanie on podmieniony na
                        przycisk do którego została przypięta funkcja.</p>
                </aside>
                <pre><code class="hljs">
            > var obj = {
                items: ['item'],
                logItems: function() {
                    console.log(this.items);
                }
            }
            > .addEventListener('click', obj.logItems);
            <span class="fragment element-log"><!--
                --><aside class="speech">
                    <p>Z tego też powodu właściwość <i>items</i> jest <u>undefined</u>, gdyż przez przypisanie zmieniliśmy
                    kontekst wywołania funkcji i <u>this</u> nie odwołuje się już do <i>obj</i> tylko do przycisku
                    który został kliknięty.</p>
                </aside><!--
                -->undefined</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Aby zapobiect takiemu niepożądanemu działaniu możemy użyć <u>bind</u>, który jako pierwszy argument
                    tak samo jak <i>call</i> i <i>apply</i> przyjmuje kontekst wywołania.</p>
                    <p>Czyli taki zapis jak na slajdzie spowoduje zmianę kontekstu wywołania z <i>przycisku</i> na
                        <i>obj</i>.</p>
                </aside>
                <pre><code class="hljs">
        > var obj = {
            items: ['item'],
            logItems: function() {
                console.log(this.items);
            }
        }
        > .addEventListener('click', obj.logItems.bind(obj));
        <span class="fragment element-log"><!--
            --><aside class="speech">
                <p>Jak widać tym razem w konsoli dostaliśmy to czego się spodziewaliśmy.</p>
            </aside><!--
            -->['item']<!--
        --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Jak widać w dokumentacji <i>bin</i> może przyjąć inne opcjonalne argumenty które reprezentują kolejne
                        argumenty w metodzie.</p>
                </aside>

                <pre><code class="hljs">
                .bind(thisArg[,  arg1[, arg2[, ...]]])
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Przy takim zapisie <i>bind</i> tworzy kopię funkcji z zapamiętanymi pierwszymi parametrami.</p>
                    <p>Ponieważ <i>bind</i> zwraca funkcję aby uzupełnić brakujący argument musimy wywołać
                    zwróconą metodę z parametrem.</p>
                </aside>
                <pre><code class="hljs">
        > function multiParams(param1, param2, param3) {
            console.log(param1, param2, param3);
        };
        > var boundMultiParams = multiParams.bind(null, 'p1', 'p2');
        > boundMultiParams('one');
        <span class="fragment element-log"><!--
            --><aside class="speech">
                <p>Jak widać mimo, że wywołaliśmy metodę tylko z jednym parametrem mamy dostęp do wszystkich 3
                które zadeklarowaliśmy w oryginalnej metodzie.</p>
                <p>
                    <i>param1</i> - 'p1'<br>
                    <i>param2</i> - 'p2'<br>
                    <i>param3</i> - 'one'
                </p>
            </aside><!--
            -->'p1' 'p2' 'one'<!--
        --></span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Teraz aby dobrze zrozumieć jak działa <i>bind</i> spróbujemy zaimplementować go sami.</p>
                </aside>
                <pre><code class="hljs">
        > var customBind = function (<span class="fragment" data-fragment-index="1"><!--
                    --><aside class="speech">
                        <p>Pierwszym argumentem będzie metoda na której ma zostać wywołany nasz <i>bind</i></p>
                    </aside><!--
                    -->method<!--
                --></span>, <span class="fragment" data-fragment-index="2"><!--
                    --><aside class="speech">
                        <p>Jako drugi argument będziemy przyjmować kontekst w którym ma zostać wywołana metoda.</p>
                    </aside><!--
                    -->context<!--
                --></span>, <span class="fragment" data-fragment-index="3"><!--
                    --><aside class="speech">
                        <p>Wszystkie kolejne argumenty potraktujemy jako argumenty metody oryginalnje które
                        mają być do niej przekazane i za pomocą <i>rest operator</i> zbierzemy je do jednej tablicy.</p>
                    </aside><!--
                    -->...bindArgs<!--
                --></span>) {
            <span class="fragment" data-fragment-index="4"><!--
                --><aside class="speech">
                    <p>Jak już powiedzieliśmy <i>bind</i> zwraca funkcję, zróbmy to samo.</p>
                </aside><!--
                -->return function (<span class="extend-args">...nestedArgs</span>) {
                <span class="fragment" data-add-slide-class-on-show="show-args" data-add-slide-class-on-hide="hide-args"  data-fragment-index="6"><!--
                    --><aside class="speech">
                    <p>Zbierzmy więc wszystkie argumenty które użytkownik przekaże podczas wywoływania naszej metody.</p>
                    <p>Musimy też połączyć je z parametrami które zostały przekazane do funkcji <i>customBind</i>,
                    zrobimy to przez połączenie tablic za pomocą <i>concat</i>.</p>
                    <p>Ostatnim krokiem jest zamiana drugiego argumentu w wywołaniu <i>apply</i> z <i>bindArgs</i> na nowo
                    utworzona zmienną <i>args</i>.</p>
                </aside><!--
                    -->var args = bindArgs.concat(nestedArgs);</span>
                <span class="fragment" data-state="test" data-fragment-index="5"><!--
                    --><aside class="speech">
                    <p>Aby wywołać oryginalną metodę ze zmienionym kontekstem wykorzystamy <i>apply</i>. Jako parametry oczywiście
                    przekażemy kontekst wywołania i zebrane wcześniej za pomocą <i>rest operator</i> argumenty.</p>
                    <p>Wiemy, że możemy też przekazywać parametry do funkcji która zostanie zwrócona przez <i>bind</i>, nam tej
                    funkcjonalności jeszcze brakuję.</p>
                </aside><!--
                    -->return method.apply(context, <span class="args-bindArgs">bindArgs</span><span class="args-args">args</span>);</span>
            }</span>
        }
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Jak mówiłem wcześniej <i>bind</i> przydaje się do zmiany kontekstu wywołania metody.</p>
                    <p>Mogą pojawić się jednak pewne problemy jeżeli nie będziemy wiedzieć jak działają pewne mechanizmy.
                    Kiedy przypinamy metodę do wywołania na jakimś zdarzeniu to automatycznie do metody jest przekazywany
                    obiekt tego zdarzenia tzw. <u>event</u>.</p>
                    <p>Czy jesteś w stanie przewidzieć rezultat wywołania tego zdarzenia?</p>
                </aside>
                <pre><code class="hljs">
        > function clickHandler(event, constParam) {
            event.preventDefault();
            console.log('constParam is', constParam);
        }
        > .addEventListener('click', clickHandler.bind(null, 'CONST'));
        <span class="fragment element-log"><!--
            --><aside class="speech">
            <p>Ponieważ <i>bind</i> łączy parametry od lewej do prawej tak prezentuje się nazwa zmiennej do jej zawartości<br>
            <i>event</i> - 'CONST'<br>
            <i>constParam</i> - '&lt;click event&gt;'</p>
        </aside><!--
            -->Uncaught TypeError: event.preventDefault is not a function</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Skoro wiemy, że <i>bind</i> przypisuje naszą wartość nie do tej zmiennej, zastosujmy najprostsze rozwiązanie
                    tego problemu. Zmieńmy kolejność parametrów, musimy pamiętać aby te parametry które mają być przekazane
                    przez <i>bind</i> muszą znajdować się na początku listy argumentów.</p>
                </aside>
                <pre><code class="hljs">
        > function clickHandler(constParam, event) {
            event.preventDefault();
            console.log('constParam is', constParam);
        }
        > .addEventListener('click', clickHandler.bind(null, 'CONST'));
        <span class="fragment element-log"><!--
            --><aside class="speech">
            <p>Jak widać po zmianie kolejności parametrów wszystko zostało podpięte pod właściwe miejsca.</p>
            <p>'constParam' został przekazany przez <i>bind</i> jako pierwszy argument natomiast <i>event</i>
            wstrzyknął swój obiekt jako drugi argument.</p>
        </aside><!--
            -->'constParam is CONST'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Aby odpalić ćwiczenia przejdź w konsoli do katalogu <i>exercises</i> i wykonaj polecenie <i>node bind.js</i></p>
                </aside>
                <img src="assets/lets-code.png" alt="let's code" class="lets-code">
            </section>
        </section>

        <section data-state="object">
            <section>
                <aside class="speech">
                    <p>Tworzenie obiektów jest jedną z podstawowych rzeczy w JS.</p>
                    <p>Istnieje jednak więcej niż jeden sposób tworzenia obiektu.</p>
                </aside>
            <pre><code class="hljs">
                <span class="fragment"><!--
                    --><aside class="speech">
                    <p>Najbardziej klasyczny dla JS, czyli obiekt <i>JSON</i>owy</p>
                </aside><!--
                    -->> var o1 = {};</span>
                <span class="fragment"><!--
                    --><aside class="speech">
                        <p>Istnieje też możliwość stworzenia nowego obiektu na podstawie już istniejącego.</p>
                    <p><i>Object.create</i> tworzy kopię obiektu ale co ważne <b>TYLKO</b> pierwszego poziomu.
                    Jeżeli będziemy mieć obiekt który jako wartości będzie miał inne obiekty one nie będą kopiowane a
                    przekazane przez referencje.</p>
                    </aside><!--
                    -->> var o2 = Object.create(sourceObj);</span>
                <span class="fragment"><!--
                    --><aside class="speech">
                        <p>Za pomocą JS możemy pisać obiektowo, w dobrych praktykach jest abyfunkcje które mają za cel
                            być konstruktorami by zaczynały się z wielkiej litery.</p>
                    </aside><!--
                    -->> function MyConstructor() {}</span>
                <span class="fragment"><!--
                    --><aside class="speech">
                        <p>Aby stworzyć nową instancję należy poprzedzić wywołanie funkcji słowe kluczowym <u>new</u>.</p>
                    </aside><!--
                    -->> var fo1 = new MyConstructor();</span>
                <span class="fragment"><!--
                    --><aside class="speech">
                        <p>Możemy też stworzyć instancję z anonimowej funkcji.</p>
                    </aside><!--
                    -->> var fo2 = new function() {};</span>
            </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Przygotujmy więc sobie obiekt na podstawie którego będziemy tworzyć</p>
                </aside>
                <pre><code class="hljs">
                > var personDraft = {
                    age: 20,
                    name: 'Unknown',
                    introduceYourself: function() {
                        console.log('Hello, my name is '
                            + this.name
                            + ' and I am '
                            + this.age
                            + ' years old');
                    }
                };
                > personDraft.introduceYourself();
                <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>Jeżeli wywołamy teraz <i>introduceYourself</i> dostaniemy wynik z domyślnymi danymi.</p>
                    </aside><!--
                    -->'Hello, my name is Unknown and I am 20 years old'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Możemy teraz stworzyć kopię obiektu źródłowego za pomocą <i>Object.create</i>
                    i zmienimy parametry…</p>
                </aside>
                <pre><code class="hljs">
                > var lucy = Object.create(personDraft);
                > lucy.name = 'Lucy';
                > lucy.age = 25;
                > lucy.introduceYourself();
                <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>…dostaniemy odpowiednio zmodyfikowany komunikat.</p>
                    </aside><!--
                    -->'Hello, my name is Lucy and I am 25 years old'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Stwórzmy teraz konstruktor za pomocą funkcji. Tworzymy funkcję która przyjmuje dwa argumenty które
                    będą wykorzystane w instancjach.</p>
                    <p>Zwróć uwagę na to, że metodę przypisujemy bezpośrednio do obiektu w konstruktorze.</p>
                </aside>
                <pre><code class="hljs">
                > var Person = function(name, age) {
                    this.name = name;
                    this.age = age;
                    this.introduceYourself = function() { /* ... */ }
                }
                > var lucy = new Person('Lucy', 25);
                > lucy.introduceYourself();
                <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>Wynik działania jest podobny do poprzednich.</p>
                    </aside><!--
                    -->'Hello, my name is Lucy and I am 25 years old'</span>
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Można też przypisać funkcje do <i>prototype</i> który jest czymś na wzór przestrzeni współdzielonej między
                    wszystkie instancje danego obiektu.</p>
                </aside>
                <pre><code class="hljs">
    > Person.prototype.introduceYourself = function() { /* ... */ }
    > var susana = new Person('Susana', 31);
    > susana.introduceYourself();
    <span class="fragment element-log"><!--
                    --><aside class="speech">
                        <p>Efekt jest taki sam jak ostatnio więc jak wybrać ten najlepszy? A może wszystkie są tak samo dobre?</p>
                    </aside><!--
                    -->'Hello, my name is Susana and I am 31 years old'</span>
                </code></pre>
            </section>

            <section>
                <aside class="speech">
                    <p>Jest różnica między sposobami tworzenia obiektów i możliwe, że w jednym projekcie będziemy wykorzystywać
                        więcej niż jedne sposób w zależności od tego jaki efekt chcemy uzyskać.</p>
                    <p>Wyjaśnijmy teraz 2 ostatnie sposoby tworzenia obiektów.</p>
                </aside>
                <table class="compare-table">
                    <tr>
                        <th>
                            <pre><code class="hljs">
    this.introduceYourself
                            </code></pre>
                        </th>
                        <th>
                            <pre><code class="hljs">
    prototype.introduceYourself
                            </code></pre>
                        </th>
                    </tr>
                    <tr>
                        <td class="fragment">
                            <aside class="speech">
                                <p>Jeżeli przypisujemy funkcje w konstruktorze to za każdym razem gdy tworzymy nową instancje
                                obiektu tworzona jest na nowo taka sama funkcja.</p>
                                <p>Może to mieć znaczenie wydajnościowe jeśli będziemy tworzyć większe ilości elementów.</p>
                            </aside>
                            <img src="assets/constructor.png" alt="constructor">
                        </td>
                        <td class="fragment">
                            <aside class="speech">
                                <p>Jeżeli jednak dodamy metodę do <i>prototype</i> jak wcześniej wspomniałem jest to przestrzeń
                                współdzielona więc za każdym razem jak będziemy tworzyć kolejne instancje będą one korzystać
                                z tej samej kopi funkcji.</p>
                            </aside>
                            <img src="assets/prototype.png" alt="prototype">
                        </td>
                    </tr>
                </table>

            </section>
            <section>
                <aside class="speech">
                    <p>Aby odpalić ćwiczenia przejdź w konsoli do katalogu <i>exercises</i> i wykonaj polecenie <i>node object.js</i></p>
                </aside>
                <img src="assets/lets-code.png" alt="let's code" class="lets-code">
            </section>
        </section>

        <section data-state="reference">
            <section>
                <aside class="speech">
                    <p>Zacznijmy od tego co to jest <i>referencja</i>? Jest to informacja o miejscu w pamięci w którym znajdują
                        się interesujące nas informacje.</p>
                    <p>Czyli jeżeli przekazujemy obiekt czy funkcje przez referęcje to tak naprawdę mówimy innemu zasobowi
                        (obiektowi, eventListenerowi, itp.) gdzie w pamięci ma szukać funkcji którą ma wywołać.</p>
                </aside>
            </section>
            <section>
                <h3>Obiekt</h3>
                <aside class="speech">
                    <p>Stwórzmy więc metodę która będzie modyfikowała przekazany obiekt.</p>
                    <p>W większości języków programowania po zmodyfikowaniu takiego obiektu obiekt oryginalny został by
                    niezmieniony a aby otrzymać zmodyfikowany obiekt należało by zwrócić go z metody, użyć wskaźników
                    lub innych mechanik dostarczanych przez dany język.</p>
                </aside>
                <pre><code class="hljs">
                    > var myObj = { key: 'value' };
                    > function addProperty(objToExtend) {
                        objToExtend.type = 'monster';
                    };
                    > addProperty(myObj);
                    > console.log(myObj);
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>W JS jednak sprawa ma się odwrotnie, wszystkie obiekty (<b>OBIEKTY</b> nie typy proste) przekazywane do funkcji
                            są referencjami do oryginalnego obiektu. Więc jego modyfikacja zmienia również obiekt
                            oryginalny.</p>
                        </aside><!--
                        -->{ key: 'value', type: 'monster' }<!--
                    --></span>
                </code></pre>
            </section>
            <section>
                <h3>Obiekt</h3>
                <aside class="speech">
                    <p>Nie zawsze jednak chcemy wykonywać operacje na obiekcie źródłowym.</p>
                    <p>Możemy więc zrobić kopie obiektu za pomocą <i>Object.create</i>, pamiętając jednak iż będzie to
                    "płaska" kopia. Czuli jeżeli nasz obiekt jako wartości ma inne obiekty to nawet po stworzeniu kopi
                    w tych właściwościach będziemy odnosić się do oryginalnego obiektu.</p>
                </aside>
                <pre><code class="hljs">
                    > var myObj = { key: 'value' }
                    > function addProperty(objToExtend) {
                        var obj = Object.create(objToExtend);
                        obj.type = 'monster';
                    };
                    > addProperty(myObj);
                    > console.log(myObj);
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Po skopiowaniu i modyfikacji obiektu który został przekazany jako argument obiekt źródłowy
                            został niezmienny.</p>
                        </aside><!--
                        -->{ key: 'value' }</span>
                </code></pre>
            </section>
            <section>
                <h3 >Obiekt</h3>
                <aside class="speech">
                    <p>Ten sam efekt można otrzymać wykorzystując <i>Object.assign</i> z ES6</p>
                </aside>
                <h3 class="slide-es6"></h3>
                <pre><code class="hljs">
                    > var myObj = { key: 'value' }
                    > function addProperty(objToExtend) {
                        var obj = Object.assign({}, objToExtend);
                        obj.type = 'monster';
                    };
                    > addProperty(myObj);
                    > console.log(myObj);
                    <span class="element-log">{ key: 'value' }</span>
                </code></pre>
            </section>

            <section>
                <h3>Tablica</h3>
                <aside class="speech">
                    <p>Jak mówiliśmy na jednym z pierwszych slajdów tablice w JS to też obiekty, więc zachowują się podobnie.</p>
                    <p>Przekazując tablicę do metody przekazujemy jej referencję co skutkuje tym, że wprowadzając jakiekolwiek
                    modyfikacje zmieniana jest tablica źródłowa.</p>
                </aside>
                <pre><code class="hljs">
                    > myArray = [1, 2, 3];
                    > function appendTo(arr) {
                        return arr.push(arr.length + 1);
                    };
                    > appendTo(myArray);
                    > console.log(myArray);
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Z tego właśnie powodu mamy tu dodatkowy element.</p>
                        </aside><!--
                        -->[1, 2, 3, 4]</span>
                </code></pre>
            </section>
            <section>
                <h3>Tablica</h3>
                <aside class="speech">
                    <p>Możemy zapobiec takiemu działaniu używając metody <i>concat</i> na pustej tablicy.</p>
                    <p>Jednak jeżeli elementami tablicy będą inne tablice lub obiekty <b>NIE</b> zostaną one skopiowane
                    więc będziemy mieli dostęp do oryginalnych elementów przez referencję.</p>
                </aside>
                <pre><code class="hljs">
                    > myArray = [1, 2, 3];
                    > function appendTo(arr) {
                        return [].concat(arr, [arr.length + 1]);
                    };
                    > appendTo(myArray);
                    > console.log(myArray);
                    <span class="fragment element-log"><!--
                        --><aside class="speech">
                            <p>Jak widać po skopiowaniu tablica wyjściowa została nienaruszona.</p>
                        </aside><!--
                        -->[1, 2, 3]</span>
                </code></pre>
            </section>
            <section>
                <h3>Tablica</h3>
                <aside class="speech">
                    <p>To samo można osiągnąć przy użyciu <i>spread operator</i>.</p>
                </aside>
                <h3 class="slide-es6"></h3>
                <pre><code class="hljs">
                    > myArray = [1, 2, 3];
                    > function appendTo(arr) {
                        return [...arr, arr.length + 1];
                    };
                    > appendTo(myArray);
                    > console.log(myArray);
                    <span class="element-log">[1, 2, 3]</span>
                    </code></pre>
            </section>

            <section>
                <h3>Funkcje</h3>
                <aside class="speech">
                    <p>Funkcje też możemy przekazywać przez referencję (z resztą już to robiliśmy w trakcie tej prezentacji).</p>
                </aside>
                <pre><code class="hljs">
                    > function getTwo() {
                        return 2;
                    };
                    > var f1 = getTwo();
                    > var f2 = getTwo;
                    > console.log(f1, f2);
                    <span class="element-log"><span class="fragment"><!--
                        --><aside class="speech">
                            <p>Do <i>f1</i> został zwrócony wynik</p>
                        </aside><!--
                        -->2</span> <span class="fragment"><!--
                        --><aside class="speech">
                            <p>Natomiast do f2 przekazana została referencję więc zamiast wyniku tej funkcji otrzymaliśmy jej ciało.</p>
                            <p>Więc jak widać aby przekazać funkcję jako referencję wystarczy zapisać ja bez nawiasów.</p>
                        </aside><!--
                        -->f () { return 2; }</span></span>
                </code></pre>
            </section>
            <section>
                <h3>Funkcje</h3>
                    <aside class="speech">
                    <p>Ta sama zasada ma się do przekazywania metod jako callbacki do innych funkcji.</p>
                    <p>Tak jak wcześniej mówiliśmy jedynym minusem takiego zapisu może być zmiana kontekstu wywołania, jednak
                    my już wiemy jak sobie z tym poradzić :)</p>
                </aside>
                <pre><code class="hljs">
                    > function sendToServer(event) { /*...*/ };
                    > document.getElementById('sendButton')
                              .addEventListener('click', sendToServer);
                </code></pre>
            </section>
            <section>
                <aside class="speech">
                    <p>Aby odpalić ćwiczenia przejdź w konsoli do katalogu <i>exercises</i> i wykonaj polecenie <i>node reference.js</i></p>
                </aside>
                <img src="assets/lets-code.png" alt="let's code" class="lets-code">
            </section>
        </section>

        <section data-state="end">
            <aside class="speech">
                <p>To już koniec ćwiczeń przewidzianych w zakresie tej prezentacji jednak jeżeli macie ochotę na
                    dodatkową porcję zadań w katalogu <i>extra-project</i> znajdziecie makietę koszyka z reserved.</p>
                <p>Znajduje się tam plik <i>README.md</i> gdzie znajdziecie instrukcję jak odpalić projekt oraz listę plików
                wraz z nr. linii w której znajduje się opis zadania.</p>
                <p>Dzięki za poświęcony czas i powodzenia :)</p>
            </aside>
            <h2>Dziękuję :)</h2>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script src="js/comparision-slider.js"></script>
<script src="js/custom.lib.js"></script>
<script>
    Reveal.initialize({
        history: true,
        transition: 'linear',
        dependencies: [
            { src: 'lib/js/classList.js' },
            { src: 'js/highlight.js', async: true, callback: () => hljs.initHighlightingOnLoad() },
            { src: 'js/notes/notes.js', async: true, callback: function () { window.localStorage.setItem('reveal-speaker-layout', 'tall'); } },
            { src: 'js/speech/speech.js', async: true }
        ]
    });

    document.addEventListener('DOMContentLoaded', function() {
        var playBtns = document.querySelectorAll('.video-wrapper .play-btn');
        for (var i = 0; i < playBtns.length; i++) {
            playBtns[i].addEventListener('click', function(e) {
                this.style.display = 'none';
                this.previousElementSibling.play();
            }, false);
        }
    }, false);
</script>
</body>
</html>
